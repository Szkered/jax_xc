import jax
import jax.numpy as jnp
import ctypes
from collections import namedtuple
from typing import Callable, Optional
from . import impl
from .utils import get_p, rho_to_arguments, call_functional

{% for name, ext_params, maple_name, ext_params_descriptions in functionals %}

def {{ name }}(
  rho: Callable,
  polarized: bool = True,
  mo: Optional[Callable] = None,
{% for param_name in ext_params.keys() %}
  {{ param_name }}: Optional[float] = None,
{% endfor %}
) -> Callable:
  r"""{{ name }} functional

  Parameters
  ----------
  rho : Callable
      The electron density function, mapping 3D coordinate to a density value.
      If polarized returns one value for each spin, :math:`\rho\in R^3 \rightarrow R^2`,
      otherwise, :math:`\rho\in R^3 \rightarrow R`.
  polarized : bool
      Whether the calculation is polarized.
  mo : Optional[Callable]
      Molecular orbital function :math:`R^3 \rightarrow R^{2 \times N}`.
      :math:`N` is the number of orbitals. It is only needed for
      mgga functionals.
{% for param_name, param_descrip in zip(ext_params.keys(), ext_params_descriptions) %}
  {{ param_name }} : Optional[float]
      {{ param_descrip }}
{% endfor %}
  """
{% for param_name, value in ext_params.items() %}
  {{ param_name }} = ({{ param_name }} or {{ value }})
{% endfor %}
  p = get_p("{{ name }}", polarized, {{ ext_params.keys()|join(', ') }})

  def _{{ name }}(r):
    return call_functional(p, rho, r, polarized, mo)
  return _{{ name }}

{% endfor %}
